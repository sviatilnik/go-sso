# SSO — сервис единого входа

Сервис аутентификации и выдачи токенов. Текущая реализация: логин по логину/паролю, выдача access- и refresh-токенов (JWT, HS256).

---

## План развития

### 1. JWT и OAuth 2

- **Текущее состояние:** выдача JWT (HS256) при логине, refresh-токен как хеш access-токена.
- **Цели:**
  - Привести выдачу токенов к модели **OAuth 2** (access token + опционально refresh token, стандартные поля `sub`, `exp`, `iat`, `scope` и т.д.).
  - Реализовать **Refresh Token flow**: отдельное хранилище refresh-токенов (БД или кэш), эндпоинт обмена refresh на новую пару токенов, ротация/отзыв refresh-токенов.
  - Добавить в JWT стандартные claims по OAuth 2 / OIDC: `iss`, `aud`, `scope`, при необходимости `roles` и кастомные claims.
  - Документировать формат токенов и контракт API (для внешних потребителей).

### 2. Асимметричные ключи и JWKS

- **Текущее состояние:** подпись JWT симметричным ключом (HS256), внешняя валидация невозможна без раскрытия секрета.
- **Цели:**
  - Перейти на **RS256** (или поддерживать и HS256 для обратной совместимости) для подписи access-токенов.
  - Генерировать или загружать пару ключей **RSA** (private — для подписи, public — для проверки). Хранить private key только на стороне SSO.
  - Реализовать эндпоинт **JWKS** (`/.well-known/jwks.json`): отдавать только публичные ключи в формате [RFC 7517](https://tools.ietf.org/html/rfc7517) (например, `n`, `e`, `kid`).
  - Поддержать **несколько активных ключей** (по `kid`), чтобы обеспечить ротацию ключей без простоя: текущий ключ для подписи, старые — только в JWKS для валидации уже выданных токенов.

### 3. Валидация токенов и консьюмеры

- **Цели:**
  - Внутри SSO: проверка входящих JWT (refresh, вызовы по токену) через публичный ключ из своей пары или через JWKS.
  - Для внешних сервисов: описание использования JWKS (URL, пример запроса ключей, пример проверки подписи и claims в своём языке/стеке).
  - Опционально: эндпоинт **Token Introspection** (OAuth 2 Token Introspection) для проверки действительности токена без разбора JWT у клиента.

### 4. Конфигурация и безопасность

- **Цели:**
  - Конфигурация ключей: путь к PEM файлам (RSA) или base64, отдельно для подписи и (при необходимости) для шифрования. Не хранить приватные ключи в коде и по возможности не в переменных окружения в проде.
  - Параметр или конфиг для выбора алгоритма подписи (RS256 / HS256) и срока жизни ключей при ротации.
  - Логирование без вывода секретов и приватных ключей.

### 5. Дальнейшие шаги (по приоритету)

| Этап | Задача |
|------|--------|
| 0 | Изменить способ конфигурации |
| 1 | Ввести RSA-пару ключей, подпись JWT по RS256 в `TokenGenerator`. |
| 2 | Реализовать `GET /.well-known/jwks.json` с публичным ключом (и при ротации — несколькими по `kid`). |
| 3 | Реализовать Refresh Token flow (хранилище, эндпоинт обмена, проверка по токену в `LoginByToken` и т.д.). |
| 4 | Добавить в JWT claims `iss`, `aud`, при необходимости `scope`/`roles`; обновить документацию API. |
| 5 | Token Introspection (опционально) и/или документация для внешней валидации по JWKS. |

---

После выполнения этапов 1–2 внешние системы смогут проверять JWT по публичным ключам из JWKS без доступа к секретам SSO; этапы 3–5 завершают базовую поддержку OAuth 2 и удобную валидацию токенов.
